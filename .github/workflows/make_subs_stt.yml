name: Make subtitles STT

on:
  repository_dispatch:
    types: [make_subs_stt]

jobs:
  make_subs:
    runs-on: ubuntu-22.04
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install system deps
        shell: bash
        run: |
          set -euo pipefail
          sudo rm -f /var/lib/apt/lists/lock /var/cache/apt/archives/lock /var/lib/dpkg/lock*
          sudo dpkg --configure -a || true

          sudo apt-get -o Acquire::Retries=5 update
          sudo apt-get -o Acquire::Retries=5 install -y --no-install-recommends \
            ffmpeg \
            python3 python3-pip \
            jq \
            fonts-montserrat fonts-noto-core

      - name: Setup env
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: auto
          R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
        run: |
          set -euo pipefail
          echo "R2 endpoint: $R2_ENDPOINT"
          echo "Triggered payload:"
          echo '${{ toJson(github.event.client_payload) }}'

      - name: Download inputs from R2 (with debug ls)
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: auto
          R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          BUCKET: ${{ secrets.R2_BUCKET }}
          VIDEO_KEY: ${{ github.event.client_payload.video_key }}
          AUDIO_KEY: ${{ github.event.client_payload.audio_key }}
        run: |
          set -euo pipefail

          if [ -z "${BUCKET:-}" ]; then
            echo "Missing R2_BUCKET secret"
            exit 1
          fi

          echo "==== DEBUG: list bucket root (first 100) ===="
          aws --endpoint-url "$R2_ENDPOINT" s3 ls "s3://$BUCKET/" | head -n 100 || true

          echo "==== DEBUG: list videos/ (first 100) ===="
          aws --endpoint-url "$R2_ENDPOINT" s3 ls "s3://$BUCKET/videos/" | head -n 100 || true

          echo "==== DEBUG: list audios/ (first 100) ===="
          aws --endpoint-url "$R2_ENDPOINT" s3 ls "s3://$BUCKET/audios/" | head -n 100 || true

          if [ -z "${VIDEO_KEY:-}" ]; then
            echo "Missing video_key in payload"
            exit 1
          fi

          echo "Downloading video: s3://$BUCKET/$VIDEO_KEY"
          aws --endpoint-url "$R2_ENDPOINT" s3 cp "s3://$BUCKET/$VIDEO_KEY" ./video.mp4

          if [ -n "${AUDIO_KEY:-}" ]; then
            echo "Downloading audio: s3://$BUCKET/$AUDIO_KEY"
            aws --endpoint-url "$R2_ENDPOINT" s3 cp "s3://$BUCKET/$AUDIO_KEY" ./audio_in
            echo "Normalizing audio -> 16k mono wav"
            ffmpeg -y -i ./audio_in -ac 1 -ar 16000 -f wav ./audio.wav
          else
            echo "No audio_key provided, extracting audio from video..."
            ffmpeg -y -i ./video.mp4 -vn -ac 1 -ar 16000 -f wav ./audio.wav
          fi

          echo "Downloaded files:"
          ls -lh

      - name: Install faster-whisper
        shell: bash
        run: |
          set -euo pipefail
          python3 -m pip install --upgrade pip
          pip install faster-whisper==1.0.3

      - name: Transcribe + build SRT + ASS (YT SHORTS POP, ONE WORD CENTER)
        shell: bash
        env:
          LANG_CODE: en
          WHISPER_MODEL: small
          OUTLINE_MODE: random   # random | green
        run: |
          set -euo pipefail

          cat > make_subs.py <<'PY'
          import os, re, random
          from faster_whisper import WhisperModel

          AUDIO = "audio.wav"
          OUT_SRT = "subs.srt"
          OUT_ASS = "subs.ass"

          lang = os.environ.get("LANG_CODE", "en")
          model_name = os.environ.get("WHISPER_MODEL", "small")
          outline_mode = os.environ.get("OUTLINE_MODE", "random")  # random | green

          model = WhisperModel(model_name, device="cpu", compute_type="int8")

          segments, info = model.transcribe(
              AUDIO,
              language=lang,
              vad_filter=True,
              word_timestamps=True
          )

          # IMPORTANT: segments is a generator -> convert once
          segments = list(segments)

          def srt_ts(t: float) -> str:
              if t < 0: t = 0
              ms = int(round(t * 1000.0))
              h = ms // 3600000; ms %= 3600000
              m = ms // 60000;   ms %= 60000
              s = ms // 1000;    ms %= 1000
              return f"{h:02d}:{m:02d}:{s:02d},{ms:03d}"

          def ass_ts(t: float) -> str:
              if t < 0: t = 0
              cs = int(round(t * 100))  # centiseconds
              h = cs // 360000; cs %= 360000
              m = cs // 6000;   cs %= 6000
              s = cs // 100;    cs %= 100
              return f"{h:d}:{m:02d}:{s:02d}.{cs:02d}"

          def clean_text(s: str) -> str:
              return re.sub(r"\s+", " ", (s or "")).strip()

          def rgb_to_ass_bgr_hex(r:int, g:int, b:int) -> str:
              # ASS wants BGR: &HBBGGRR&
              return f"&H{b:02X}{g:02X}{r:02X}&"

          OUTLINE_PRESET = [
              (0, 255, 0),      # green
              (0, 200, 255),    # cyan
              (255, 0, 255),    # magenta
              (255, 255, 0),    # yellow
              (255, 120, 0),    # orange
          ]

          def pick_outline_color(mode="random") -> str:
              if mode == "green":
                  return rgb_to_ass_bgr_hex(0, 255, 0)
              r,g,b = random.choice(OUTLINE_PRESET)
              return rgb_to_ass_bgr_hex(r,g,b)

          # ---- SRT by segments ----
          srt_lines = []
          idx = 1
          for seg in segments:
              start = float(seg.start)
              end = float(seg.end)
              text = clean_text(seg.text)
              if not text:
                  continue
              srt_lines.append(str(idx))
              srt_lines.append(f"{srt_ts(start)} --> {srt_ts(end)}")
              srt_lines.append(text)
              srt_lines.append("")
              idx += 1

          with open(OUT_SRT, "w", encoding="utf-8") as f:
              f.write("\n".join(srt_lines))

          # ---- ASS: one word centered + YT Shorts pop ----
          # If Montserrat isn't available, change Fontname to "Noto Sans"
          ass_header = r"""[Script Info]
          ScriptType: v4.00+
          PlayResX: 1080
          PlayResY: 1920
          WrapStyle: 0
          ScaledBorderAndShadow: yes

          [V4+ Styles]
          Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
          Style: Word,Montserrat,120,&H00FFFFFF,&H00FFFFFF,&H0000FF00,&H00000000,1,0,0,0,100,100,0,0,1,10,0,5,0,0,0,1

          [Events]
          Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
          """

          ass_lines = [ass_header]

          for seg in segments:
              words = getattr(seg, "words", None) or []
              for w in words:
                  token = (w.word or "").strip()
                  if not token:
                      continue

                  start = float(w.start)
                  end = float(w.end)

                  # Avoid micro-blinks
                  min_dur = 0.12
                  pad_end = 0.04
                  if end - start < min_dur:
                      end = start + min_dur
                  end += pad_end

                  # Sanitize ASS braces
                  token = token.replace("{", "(").replace("}", ")")

                  ol = pick_outline_color(outline_mode)

                  # Center immediately + "pop" (scale+blur+alpha -> settle)
                  override = (
                      r"{"
                      r"\an5"
                      r"\pos(540,960)"

                      r"\fscx170\fscy170"
                      r"\blur2.2"
                      r"\alpha&HCC&"

                      r"\t(0,90,\fscx110\fscy110\blur0.6\alpha&H00&)"
                      r"\t(90,150,\fscx100\fscy100\blur0.0)"

                      r"\bord10"
                      rf"\3c{ol}"
                      r"\1c&H00FFFFFF&"

                      r"\shad4\4c&H000000&"
                      r"}"
                  )

                  text = override + token

                  ass_lines.append(
                      f"Dialogue: 0,{ass_ts(start)},{ass_ts(end)},Word,,0,0,0,,{text}"
                  )

          with open(OUT_ASS, "w", encoding="utf-8") as f:
              f.write("\n".join(ass_lines))

          print("Wrote:", OUT_SRT, OUT_ASS)
          print("ASS lines:", len(ass_lines))
          PY

          python3 make_subs.py
          wc -l subs.ass
          ls -lh subs.srt subs.ass

      - name: Burn ASS subtitles into video
        shell: bash
        run: |
          set -euo pipefail
          ffmpeg -y -i video.mp4 -vf "ass=subs.ass" -c:v libx264 -preset veryfast -crf 20 -c:a aac -b:a 192k out_subbed.mp4
          ls -lh out_subbed.mp4

      - name: Upload results to R2
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: auto
          R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          BUCKET: ${{ secrets.R2_BUCKET }}
          VIDEO_ID: ${{ github.event.client_payload.video_id }}
        run: |
          set -euo pipefail

          if [ -z "${BUCKET:-}" ]; then
            echo "Missing R2_BUCKET secret"
            exit 1
          fi

          if [ -z "${VIDEO_ID:-}" ]; then
            VIDEO_ID="$(date +%s)_$RANDOM"
          fi

          aws --endpoint-url "$R2_ENDPOINT" s3 cp ./subs.srt "s3://$BUCKET/subs/${VIDEO_ID}.srt"
          aws --endpoint-url "$R2_ENDPOINT" s3 cp ./subs.ass "s3://$BUCKET/subs/${VIDEO_ID}.ass"
          aws --endpoint-url "$R2_ENDPOINT" s3 cp ./out_subbed.mp4 "s3://$BUCKET/final/${VIDEO_ID}_subbed.mp4"

          echo "Uploaded:"
          echo "subs/${VIDEO_ID}.srt"
          echo "subs/${VIDEO_ID}.ass"
          echo "final/${VIDEO_ID}_subbed.mp4"
